Truths = {'High-Level Scripting Programming', 'Iterative Programming', 'Event Streaming Programming', 'Macro Programming', 'Low-Level Programming Paradigms', 'High-Level Programming Paradigms', 'Static Typing Paradigms', 'Concurrent Programming', 'Class-Based Programming', 'Reactive Programming', 'Template Metaprogramming', 'Aspect-Oriented Programming', 'Constraint Programming', 'Dynamic Typing Paradigms', 'Pure Functional Programming', 'Functional Reactive Programming', 'Imperative Programming', 'Component-Based Programming', 'Loop-Based Paradigms', 'Managed Memory Paradigms', 'Actor Model Programming', 'Object-Oriented Programming', 'Meta-Programming', 'Recursive Programming', 'Purely Statically Typed Programming', 'Event-Driven Programming', 'Eager Evaluation Paradigms', 'Prototype-Based Programming', 'Sequential Programming', 'Lazy Evaluation Paradigms', 'Procedural Programming', 'Scripting Programming', 'Array Programming', 'Visual Programming', 'Logic Programming', 'Immutable Data Structures Programming', 'Code Generation', 'Parallel Programming', 'Minimalist Programming', 'Functional Programming', 'Strongly Typed Languages', 'Declarative Programming', 'Dataflow Programming'}
Actions = {'Calculating Lines of Code per Function', 'Measuring Cyclomatic Complexity', 'Observing Side Effects', 'Analyzing Class Usage', 'Detecting Event Listeners', 'Evaluating Type Inference', 'Examining Tail Recursion', 'Measuring Recursion Depth', 'Checking for Pattern Matching', 'Examining Higher-Order Functions', 'Assessing State Mutability', 'Checking for Monads', 'Detecting Lazy Evaluation', 'Assessing Concurrency Usage Percentage', 'Analyzing Use of Pointers'}
Outcomes = {'Analyzing Class Usage': {'type': 'str', 'states': {'Extensive Use of Classes': {'Procedural Programming', 'Logic Programming', 'Functional Reactive Programming', 'Functional Programming', 'Dataflow Programming'}, 'Minimal Use of Classes': {'Object-Oriented Programming', 'Prototype-Based Programming'}, 'No Use of Classes': {'Object-Oriented Programming', 'Class-Based Programming', 'Component-Based Programming'}}}, 'Examining Higher-Order Functions': {'type': 'str', 'states': {'Frequent Higher-Order Functions': {'Object-Oriented Programming', 'Imperative Programming', 'Procedural Programming'}, 'Rare Higher-Order Functions': {'Functional Programming', 'Functional Reactive Programming'}, 'No Higher-Order Functions': {'Functional Programming', 'Declarative Programming', 'Dataflow Programming'}}}, 'Assessing State Mutability': {'type': 'str', 'states': {'Predominantly Immutable State': {'Object-Oriented Programming', 'Imperative Programming', 'Procedural Programming'}, 'Mixed Mutability': {'Immutable Data Structures Programming', 'Pure Functional Programming'}, 'Highly Mutable State': {'Functional Programming', 'Reactive Programming'}}}, 'Detecting Event Listeners': {'type': 'str', 'states': {'Extensive Event Listeners': {'Functional Programming', 'Procedural Programming'}, 'Limited Event Listeners': {'Event-Driven Programming', 'Reactive Programming'}, 'No Event Listeners': {'Event Streaming Programming', 'Event-Driven Programming', 'Reactive Programming'}}}, 'Checking for Monads': {'type': 'str', 'states': {'Monads Present': {'Object-Oriented Programming', 'Imperative Programming', 'Procedural Programming'}, 'No Monads Detected': {'Functional Programming', 'Pure Functional Programming'}}}, 'Evaluating Type Inference': {'type': 'str', 'states': {'Strong Type Inference': {'Dynamic Typing Paradigms', 'Scripting Programming'}, 'Weak or No Type Inference': {'Static Typing Paradigms', 'Strongly Typed Languages'}, 'Mixed Typing': {'Purely Statically Typed Programming'}}}, 'Observing Side Effects': {'type': 'str', 'states': {'No Side Effects': {'Object-Oriented Programming', 'Imperative Programming', 'Procedural Programming'}, 'Controlled Side Effects': {'Pure Functional Programming'}, 'Frequent Side Effects': {'Functional Programming', 'Declarative Programming'}}}, 'Examining Tail Recursion': {'type': 'str', 'states': {'Extensive Tail Recursion': {'Loop-Based Paradigms', 'Imperative Programming'}, 'Limited Tail Recursion': {'Functional Programming', 'Recursive Programming'}, 'No Tail Recursion': {'Functional Programming', 'Recursive Programming'}}}, 'Checking for Pattern Matching': {'type': 'str', 'states': {'Pattern Matching Used': {'Object-Oriented Programming', 'Procedural Programming'}, 'No Pattern Matching': {'Functional Programming', 'Logic Programming'}}}, 'Detecting Lazy Evaluation': {'type': 'str', 'states': {'Lazy Evaluation Present': {'Imperative Programming', 'Eager Evaluation Paradigms'}, 'Strict Evaluation': {'Functional Programming', 'Lazy Evaluation Paradigms'}, 'Mixed Evaluation': set()}}, 'Analyzing Use of Pointers': {'type': 'str', 'states': {'Frequent Pointer Usage': {'Managed Memory Paradigms', 'Scripting Programming'}, 'No Pointer Use': {'Low-Level Programming Paradigms', 'Procedural Programming'}, 'Abstracted Pointers': {'High-Level Programming Paradigms'}}}, 'Measuring Cyclomatic Complexity': {'type': 'float', 'states': {(0, 5): {'Functional Reactive Programming', 'Aspect-Oriented Programming', 'Meta-Programming'}, (6, 15): {'Constraint Programming', 'Logic Programming'}, (16, 100): set()}}, 'Calculating Lines of Code per Function': {'type': 'float', 'states': {(0, 20): {'Macro Programming', 'Template Metaprogramming', 'Code Generation'}, (21, 100): {'Array Programming', 'Minimalist Programming'}, (101, 1000): {'Visual Programming', 'High-Level Scripting Programming'}}}, 'Assessing Concurrency Usage Percentage': {'type': 'float', 'states': {(0, 10): {'Concurrent Programming', 'Actor Model Programming', 'Parallel Programming'}, (11, 100): {'Sequential Programming', 'Procedural Programming'}}}, 'Measuring Recursion Depth': {'type': 'float', 'states': {(0, 5): {'Functional Programming', 'Recursive Programming'}, (6, 20): {'Procedural Programming', 'Iterative Programming'}}}}
